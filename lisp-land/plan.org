* Вступление 
** Что делает лисп таким крутым и необычным?
Лисп это очень выразительный язык. Это значит что множество идей можно выразить
маленьким количеством текста.
** Если лисп такой замечательный, то почему множество людей его не использует?
Это не совсем так, лисп используется во многих вещах.
Но основная причина почему он так непопулярен заключается в 3 правилах:
1. То что учит много людей (С++)
2. То что легко изучить (Ruby, Python, js)
3. То что имеет лёгко оценимую ценность (Атомная физика, вкусный бутерброд)
   
Лисп не относится ни к одному из 3-х правил.
** Откуда пришёл лисп?
Давным давно языки были привязаны к машинам и были примитивны.
После появились ассемблеры, но они всё ещё были привязаны к архитектуре.
Потом появился FORTRAN, BASIC, C
Потом в MIT 1959 году появился лисп и развился в Maclisp и Interlisp
Но наступила зима, CISC и RISC оказались эффективнее и лисп умер (конец).
Потом появились C#, Java.
** Откуда лисп берёт свою силу?
Лисп позволяет писать любую конструкцию и не ждать пока её добавят в язык

* 1 Лисп это сила.
** Диалекты лиспа.
Любой язык, подчиняющийся цетральным принципам Лиспа,
считается диалектом лиспа.
Подовляющее большинство сообщества лиспа использует два лиспа:
Common Lisp и Scheme. Эта книга о Common lisp.
** Сказка о двух лиспах
Грязный common lisp
Академичный scheme
Другого нет.
** Новые лиспы
Clojure и Ark(умер)
** Диалекты лиспа для скриптов
1. Emacs lisp
2. Guile scheme
3. ScriptFu scheme
** ansi common lisp
В 1981 году, решили сделать спецификацию для нового диалекта который назвали
common lisp. В 1986 году был превращён в ansi common lisp.
** Итогы
1. Существуют 2 диалекта лиспа: Common lisp и scheme.
2. Common lisp это мультипарадигмальный язык.
3. можно вводить команды в REPL.
* 2 Создание своей первой лисп программы.
** Написали guess-my-number

Объявить глобальную переменную
#+BEGIN_SRC lisp
  (defparameter *name* 10)
#+END_SRC

Объявить функцию
#+BEGIN_SRC lisp
  (defun name (args) 'body)
#+END_SRC

Объявить локальную переменную
#+BEGIN_SRC lisp
  (let (var declarations) 'body)
#+END_SRC

Объявить локальную функцию
#+BEGIN_SRC lisp
  (flet ((function-name (args) 'body)) 'body)
#+END_SRC

Объявить локальную функцию с рекурсивными привязками
#+BEGIN_SRC lisp
  (labels ((function-name (args) 'body)) 'body)
#+END_SRC

* 3 Изучение синтаксиса лисп кода
** Синтаксис и семантика
Синтаксис - это то по каким правилам написано.
Семантика - это то какой смысл содержится в написаном.
Лисп отличается благодаря простому синтаксису от любых других языков.
** Строительные блоки синтаксиса лиспа
Если бы пришлось писать компилятор С++, пришлось бы проделать огромную
работу, чтобы компилятор смог это запустить. Написать компилятор или
интерпретатор лиспа гораздо проще.

#+BEGIN_SRC lisp
  (defun square (n)
    (* n n))
#+END_SRC

Лисп использует скобки для организации кода, похожий на списки
'(bla bla bla)
** Символы
Символы в лисп - это слово. Символы состоят из букв, цифр и знаков.
Символы в Common lisp не чувствительны к регистру.
Чтобы сравнить символы можно использовать eq

#+BEGIN_SRC lisp
  (eq 'fooo 'FoOo)
#+END_SRC

** Числа
100 - целые
1.00 - плавающие
2/3 - дробные
1578109481092840918209812093 - бесконечные
** Строки
"Tutti Frutti" - строка

Распечатаем строку

#+BEGIN_SRC lisp
  (print "Tutti Frutti")
#+END_SRC

Экранируем кавычки

#+BEGIN_SRC lisp
  (print "He yelled \"Stop that thief!\" from the busy street.")
#+END_SRC

** Как лисп различает код и данные
Синтаксис лиспа имеет специальный способ различать код и данные.

Код мод:

Когда мы пишим что-то, лисп предполагает, что вы пишете код.
Код должен быть в особом типе списка: форме.
форма -> (foo bla bla bla)
          ^- комманда
Форма - это просто список с оператором в начале.
Сначала лисп вычисляет все аргументы а после выполняет оператор.

Дата мод:

Режим данных представляет наши формы как данные и не вычисляет их.
Чтобы сказать что форма это данные нужно поставить кавычку '(expt 2 3).

** Списки в лиспе
Списки - важнейшая особенность Lisp.
Именно они объединяют весь Lisp-код (а также данные).
(expt 2 3) <- данный список содержит символ expt и 2 числа.
В основном программа в лиспе состоит из списков,
а так же символов, чисел, строк, векторов..

Списки состоят из cons ячеек - (a . b).
Списки это лишь иллюзия.

((1) ((2) ((3) (nil))))

** Функции списка
Чтобы манипулировать ячейками cons в Лиспе есть три основные функции:
cons, car и cdr.

Чтобы связать любые две части данных, обычный способ сделать это -
использовать функцию cons. При вызове cons - компилятор выделяет
небольшой участок памяти, ячейку cons, которая может содержать две
ссылки на связываемые объекты.

#+BEGIN_SRC lisp
    (cons 'chicken 'cat)
#+END_SRC
результат (CHICKEN . CAT)

точка в середине списка означает cons-ячейку.
Если добавить nil в правую часть, произойдёт нечто особенное.

#+BEGIN_SRC lisp
  (cons 'chicken 'nil)
#+END_SRC
результат (CHICKEN)

nil используется для завершения списка и поэтому это отображается так.
Так же 'nil это эквивалент () - пустой список.
Так же если нам нужно добавить в начало списка элемент мы так же можем
вызвать cons

#+BEGIN_SRC lisp
  (cons 'pork '(beef chicken))
#+END_SRC

и понять что все примеры выглядят на самом деле так

(cons 'pork (cons 'beef (cons 'chicken ())))


функция car возвращает голову списка, а cdr конец со второго элемента

Есть функция для упрощения всего list.

(list 'pork 'beef 'chicken)

** Вложеные списки
Список содержащий другие списки:
'(cat (duck bat) ant)


** Итогы
1. Круглые скобки нужны чтобы свести кол-во синтаксиса к минимуму.
2. Списки состоят из cons ячеек
3. Можно создать список с помощью cons
4. Можно проверить часть списка с помощью car и cdr

* 4 Принятие решений с условиями
** Симметрия nil и ()
Программы на лисп пронизаны симметрией

Пустые списки считаются ложными значениями

#+BEGIN_SRC lisp
  (if '()
      'i-am-true
      'i-am-false) ;; I-AM-FALSE

  (if '(1)
      'i-am-true
      'i-am-false) ;; I-AM-TRUE
#+END_SRC

Определим функцию которая считает длину списка

#+BEGIN_SRC lisp
  (defun my-length (list)
    (if list
        (1+ (my-length (rest list)))
        0))

  (my-length '(list with four symbols))
#+END_SRC

** Четыре маскировки ()
Пустой список не только имеет значение false, но и является единственным
ложным значением в Common Lisp.

'() = () = 'nil = nil

** Условия: if и не только

(if t 'then 'else)

if - это спецальная форма которая определенным образом оценивает аргументы.

** when и unless альтернативы

(when t 'some)
(unless nil 'some)

** Команда которая делает всё: cond
Форма cond - это классический способ ветвления в Lisp.

#+BEGIN_SRC lisp
(cond
     ((> 5 10) 'WOW)
     (t 'some))
#+END_SRC

** Ветвление с помощью case
Case рассматривает 1 значение, а после автоматически их сверяет с случаями

#+BEGIN_SRC lisp
  (defun putting-eater (person)
    (case person
      ((henry) 'bad)
      ((johnny) 'hope)
      (otherwise 'stranger)))
#+END_SRC

case использует eq для сравнения, поэтому можно использовать только на
символах

** Крутые штуки с условиями

#+BEGIN_SRC lisp
  (and (oddp 5) (oddp 7) (oddp 9))

  (or (odd 4) (oddp 7) (oddp 8))

  (if *file-modified*
      (if (ask-user-about-saving)
          (save-file)))

  ;; =>

  (and *file-modified* (ask-user-about-saving) (save-file))

  ;; =>

  (if (and *file-modified*
           (ask-user-about-saving))
      (save-file))

#+END_SRC

** Использование функций, которые возвращают не только истину

Например благодаря такому подходу common lisp к истине
Можно использовать функцию member для проверки в условии

#+BEGIN_SRC lisp
  (if (member 1 '(3 4 1 5))
      'one-is-in-the-list
      'one-is-not-in-the-list)
#+END_SRC

member возвращает '(1 5) (хвост списка где был найден аргумент)
Поскольку мы можем возвращать не только t а другое значение
и возвращение чего-то другого по сути является бесплатным,
то разработчики функции решили возвращать хвост поскольку
это может быть полезным.

одной из функций которая действительно выигрывает от богатых возвращаемых
значений, является find-if

#+BEGIN_SRC lisp
  (find-if #'oddp '(2 4 5 6)) ; 5

  (if (find-if #'oddp '(2 4 5 6))
      'there-is-an-odd-number
      'there-is-no-odd-number) ; 'there-is-an-odd-number

  (find-if #'null '(2 4 nil 6)) ; nil в условном операторе плоха
#+END_SRC

** Сравнение вещей: eq, equal и другие
В лиспе много красивой симметрии. Однака есть часть которая не так красива,
связана с командами для сравнения вещей.
Если нужно сравнить два значения то можно найти обескураживающий
ассортимент различных функций, которые пытаются это сделать.
Такие как equal, eql, eq, =, string-equal и equalp. =(

Следует следовать этим правилам Конрада для сравнения:

1. Использовать eq для сравнения символов
2. Использовать equal для всего остального
   
eql похожа на eq, но она также обрабатывает числа и знаки

equalp такая же как equal, но она опускает например регистры строк
и может сравнивать целые с плавающими.

Остальные комманды сравнения являются лишь специализациями для данных.
Например = - для чисел; string-equal - строки; char-equal - знаки
** Итогы

1. Значения nil, 'nil, () и '() - это практически одно и тоже в CL.
2. Лисп позволяет легко проверять пустые списки, это упрощает написание
   пожирателей списков
3. Команды сравнения лиспа, такие как if, оцениваются по особому.
4. Если нужна команда которая делает всё, то лучше использовать cond.
5. Сравнение в lisp довольно сложное, использовать eq для символов,
   а equal для всего остального.
* 5 Создание своего текстового движка
** Итогы
1. Мир игры может быть представлен математическим графом, состоящим из узлов для мест,
   которые может посетить игрок, ребер для путей между этими местами.
2. Узлы можно хранить в ассоциативном списке (alist).
   Список позволяет искать свойства узла/места.
   Используется функция assoc для поиска ключа в списке.
3. Квазицитирование - это техника, позволяющая вставлять фрагменты
   кода в фрагменты данных.
4. Некоторые функции принимают другие функции, эти функции называются
   функции высшего порядка. mapcar - самая популярная функция высшего порядка в
   common lisp.
5. Чтобы заменить значение из списка, вы помещаете в список новые элементы.
   Функция assoc сообщит только самое последнее значение.
* 6 Взаимодействие с миром. Чтение и Считывание в Лисп.
** Печать и чтение текста
Для чтения и печати есть 2 функции read и print.
#+BEGIN_SRC lisp
  (print "foo") ; => "foo"
#+END_SRC

Но многие lisp программисты предпочитают prin1.
Разница между print и prin1 в том что prin1 не делает перенос на новую
строку.

** Скажи привет пользователю

#+BEGIN_SRC lisp
  (defun say-hello ()
    (print "Please type your name:")
    (let ((name (read)))
      (print "Nice to meet you, ")
      (print name)))
#+END_SRC

** Начало с print и read
print и read используют текст окружённый кавычками.

#+BEGIN_SRC lisp
  (defun add-five ()
    (print "please enter a number:")
    (let ((num (read)))
      (print "When I add five I get")
      (print (+ num 5))))
#+END_SRC

read читает симметрично что печатает print.

#\newline #\tab #\space - знаки в lisp

Так же можно создать символы чувствительные к регистру округляя
их в ||, таким образом символ |CaseSensitiveSymbol| сохранит свой регистр.

** Чтение и печать вещей так, как это люди предпочитают

|                 | печать вещей | чтение вещей |
| для компьютеров | print        | read         |
| для людей       | princ        | ???          |

Самый простой способ прочитать то что ввёл пользователь было бы
Просто вводить всё пока не нажата клавиша ENTER, а затем
рассматривать это всё как строку.
Функция которая это делает называется read-line.

#+BEGIN_SRC lisp
  (defun say-hello ()
    (princ "Please type your name:")
    (let ((name (read-line)))
      (princ "Nice to meet you, ")
      (princ name)))
#+END_SRC

** Симметрия между кодом и данным в Лисп
Лисп имеет очень элегантные и симметричные средства для передачи
необработанных строковых данных из внешнего мира и преобразования их
в синтаксические выражения Лиспа и обратно.

Но лисп обладает ещё более глубокой симметрией. Он может
рассматривать код и данные как взаимозаменяемые. Язык который может
это делать называется гомоиконическим.

Возможности цитирования и квазицитирования в лиспе несколько ограничены.
Что делать если мы хотим сгенерировать кусок кода лисп с нуля и после
захотим его выполнить?
Сохраним кусок кода в переменной

#+BEGIN_SRC lisp
  (defparameter *foo* '(+ 1 2))
#+END_SRC

Как выполнить код в переменной *foo*? Чтобы сделать это возможным
нам нужна команда eval.

#+BEGIN_SRC lisp
  (eval *foo*) ; => 3
#+END_SRC

** Итогы
1. Функция печати и чтения позволяют напрямую общаться с пользователем
   через консоль.
2. Другие функции ввода/вывода не так элегантны как read и print, но более
   дружелюбны для взаимодейтсвия с человеком. Как princ и read-line.
3. Гомоиконический язык программирования хранит программный код и
   программные данные в одинаковом формате. Функция цитирования,
   квазицитирования, считывания и макросов в лиспе делают его гомоиконичным
4. Очень легко написать свой repl
5. Внутренние данные Lisp можно легко преобразовать в формат,
   наиболее подходящий для интерфейса вашей программы. Это позволяет легко
   отделить детали предствления от внутренних структур данных вашей программы.
   
* 6.5 Лямбда функция
** Что такое лямбда
Лямбда позволяет создать функцию, не давая ей имени. Например, допустим, мы
создаём функцию half, которая берет число и делит его пополам. До сих пор мы
писали такую функцию следующим образом

#+BEGIN_SRC lisp
  (defun half (n)
    (/ n 2))
#+END_SRC

В Лиспе функции - это значения, которые мы можем просматривать и передавать так же, как
если бы это были числа или списки.
Чтобы получить функцию представленную значением нужно использовать оператор function.
#'half

Комманда lambda позволяет сделать эти две вещи за 1 шаг. Определить функцию и
получить её значение.

#+BEGIN_SRC lisp
  (lambda (n) (/ n 2))
#+END_SRC

** Почему лямбда так важна
В чисто математическом смысле лямбда - это единственная команда Лиспа!

** Итогы
1. Используя lambda, можно создать функцию не давая ей имя.
2. Множество функций в Лиспе принимают функции как параметры.
   
* 7 Выходим за рамки базовых списков
Списки состоят из cons ячеек (cons 1 (cons 2 (cons 3 nil)))
и печатаются как (1 2 3) если на конце nil

** Точечный список
Что произойдёт, если попытаться создать список из 1 2 3 следующим образом
(cons 1 (cons 2 3))

Список распечатается так (1 2 . 3) чтобы показать что последний элемент списка не nil
Такой список называется ТОЧЕЧНЫЙ СПИСОК.
Точечные списки в лиспе не особо полезны при написании програм на лиспе,
но можно часто сталкиваться с ненулевым значением в конце цепочки ячеек cons.

Другой способ рассматривать точечную нотацию -
рассматривать её как альтернативный синтаксис для
команды cons, используемой в режиме данных.
'(1 . (2 . (3 . nil)))

** Пары
Одной из самых распространенных и практичных применений точечных списков -
представление пар.
Пара из 2 и 3 была бы (cons 2 3) => (2 . 3)

Это очень удобно и эффективно, члены пар можно извлекать с помощью
стандратных фукнций car и cdr, их можно применить для координат или пары ключ/значение.

** Циклический список
Каждая ячейка cons в списке теоретически существует как отдельный объект в памяти.
Поскольку слоты car и cdr в ячейке могут указывать на любой объект в памяти,
ячейка cons может указывать на предыдущую ячейку cons списка.
Такой список называется ЦИКЛИЧЕСКИЙ СПИСОК.

прежде чем эксперементировать с циклическими списками нужно выполнить команду

#+BEGIN_SRC lisp
  (setf *print-circle* t)
#+END_SRC

Установка переменной *print-circle* предупреждает Lisp о том что разработчик
будет работать с самореферентными структурами данных, и что ему нужно быть
осторожным при печати на экране.

** Ассоциативные списки
alist состоит из пар ключ/значение, хранящихся в списке.

По соглашению, если ключ встречается в списке несколько раз,
предполагается, что первое появление ключа содержит нужное значение.

#+BEGIN_SRC lisp
  (defparameter *drink-order* '((bill . double-express)
                                (lisa . small-drip-coffe)
                                (john . medium-latte))
#+END_SRC

чтобы посмотреть значение по ключу существует функция assoc

#+BEGIN_SRC lisp
  (assoc 'lisa *drink-order*)
#+END_SRC

допустим мы решили изменить значение в списке, тогда это можно сделать с
помощью функции push

#+BEGIN_SRC lisp
  (push '(lisa . large-mocha-with-whipped-cream) *drink-order*)
#+END_SRC

Если нет ограничений по производительности то манипулирование cons ячейками
очень удобно в использовании и отладке.

** Графы
#+BEGIN_SRC lisp
  (defparameter *house* '((walls (mortar
                                  (cement)
                                  (water)
                                  (sand))
                           (bricks))
                          (windows (glass)
                           (frame)
                           (curtains))
                          (roof (shingles)
                           (chimney))))
#+END_SRC
Структура хранящаяся в *house* является древовидной структурой.

В математике граф состоит из множества узлов, соединенных ребрами.
Эти узлы иил ребра могут иметь дополнительные данные, связанные с ними.

В прошлый раз мы хранили карту дома волшебника (которая состояла из направленного графа)
в двух списках: один содержал информацию об узлах, а другой информацию о рёбрах.

** Итогы
1. В лиспе можно создать списки, которые заканчиваются значением, отличным от nil.
   Такие списки отображаются с дополнительной точкой перед последним элементом
   и называются тчечными списками.
2. Пары - это то, что получается при соединении двух элементов, которые сами по
   себе не являются списками. Их также можно рассматривать как точечные списки,
   содержащие только два элемента.
3. Круговые списки - это списки, в которых последняя ячейка cons указывает на
   предыдущую ячейку cons в том же списке.
4. Ассоциативные списки (alist) - это списки пар.
   Они могут использоваться для хранения данных
   в виде ключей, связанных со значениями.
5. Синтаксические выражения Лиспа отлично подходят для хранения
   и визуализации спископодобных и иерархических данных.
   Для визуализации более сложных данных могут пригодиться дополнительные инструменты.
6. Если данные представленные в виде математического графика, полезно иметь возможность
   генерации изображений данных с помощью Graphviz.
7. Распространенной техникой генерации текстовых данных в Lisp-программах является
   написание функций который выводят текст на консоль для удобства отладки и оборачивают
   эти функции в подпрограммы. Затем вы можете послать эти фрагменты другим функциям,
   которые перехватывают вывод консоли и направляют текст в нужное место, например,
   записывают его в файл.

* 8 Это тебе не прихоть твоего папочки
** Итогы
1. Функция loop позволяет нам перебирать различные типы данных.
2. Функция set-difference позволяет определить, какие элементы
   есть в одном списке, но нет в другом.
3. Функция intersection позволяет определить, какие элементы
   являются общими для списков.
4. Функция remove-duplicates удаляет дубликаты из списка.
* 9 Продвинутые типы данных и обобщённое программирование
С помощью ячеек cons, символов, строк и числовых типов данных,
можно достич многого. Common lisp содержит гораздо больше типов
данных, которые выходят далеко за рамки этих основ.
** Массивы
Массив похож на список. Основное преимущество использования
массивов заключается в том. что для доступа к значению в любом
месте требуется константное время.

Создание новых массивов

#+BEGIN_SRC lisp
  (make-array 3)
#+END_SRC

Это создаст массив длины 3. Чтобы получить и установить
элемент в массиве, используется функция aref.

#+BEGIN_SRC lisp
  (defparameter x (make-array 3))

  (setf (aref x 1) 'foo)

  (aref x 1)
#+END_SRC

Хотя команда aref обычно используется для получения значения
из массива, при специальном использовании, описанном в примере,
она позволяет нам установить значение в массиве.

Считается, что common lisp поддерживает общие сеттеры.
Это значит что в большинстве случаев код для извлечения значения из
структуры данных идентичен коду для помещения данных в эту же
структуру.

Пример со списком.

#+BEGIN_SRC lisp
  (setf foo '(a b c))

  (second foo)

  (setf (second foo) 'z)
#+END_SRC

Чтобы понять преимущество массивов, нужно сравнить их со списками.
Например есть функция доступа к элементу списка nth по номеру

#+BEGIN_SRC lisp
  (nth 1 '(foo bar baz))
#+END_SRC

Однако смысл использовать nth имеет только для очень маленьких
списков.

nth переберёт все элементы списка, а aref найдёт на прямую.
Можно не только получать быстро доступ к значениям, но и
изменять их в любом месте.
** Хеш-таблицы
Все современные языки предлагают тип данных хеш-таблицы.
Поскольку хеш-таблицы это очень эффективный инструмент.

Чтобы создать хеш-таблицу

#+BEGIN_SRC lisp
  (make-hash-table)
#+END_SRC

Как и alist, хеш-таблицы хранят элементы с помощью ключа
поиска и значения.

Чтобы извлеч элемент нужно вызвать функцию gethash

#+BEGIN_SRC lisp
  (defparameter x (make-hash-table))

  (gethash 'yup x)
#+END_SRC

** Возвращение нескольких значений
Common lisp позволяет возвращать в качестве результата более
одного значения. Некоторые функции ядра уже это делают

#+BEGIN_SRC lisp
  (round 2.4)
  ; 2
  ; 0.4
#+END_SRC

Чтобы вернуть из функции несколько значений, используется функция
values

#+BEGIN_SRC lisp
  (defun foo ()
    (values 3 7))
#+END_SRC

Лисп считает первое значение более важным и использует его по
умолчанию.

#+BEGIN_SRC lisp
  (+ (foo) 5) ; 8
#+END_SRC

В этом случае оператор сложения просто игнорирует второе значение,
которое возвращает foo. Однако если нужно использовать доп. значение,
нужно вызвать функцию multiple-value-bind

#+BEGIN_SRC lisp
  (multiple-value-bind (a b) (foo)
    (* a b))
#+END_SRC

На самом деле, более современные диалекты Лиспа, вообще не поддерживают
множественные значения. Вместо этого они просто возвращают список в тех
редких случаях, когда необходимо вернуть более одного значения.

** Производительность хеш-таблицы
Если в таблице 10 элементов и обращение происходит в среднем за 1
миллисекунду, тогда даже из за устройства хеш-таблиц
при 1 000 000 элементов, мы все равно можем ожидать получение
элемента за около 1 миллисекунды.
Однако не всегда можно ожидать наилучшей производительности
1. Подкачка виртуальной памяти и пропуски кэша:
   Как и в случае с массивами, большие хеш-таблицы могут
   заставить ОС начать подкачку виртуальной памяти на
   жёский диск, что снижает производительность.
   Аналогично, они могут увеличить кол-во пропусков кэша
   в процессоре.
2. Коллизии хэша:
   Внутри хэш-таблиц используется спецальная функция,
   называемая хэш-функцией, которая преобразует ключи в числа.
   Такая хэш-функция может вызывать хэш-коллизии. По сути,
   хэш-коллизия происходит, когда случайно два ключа
   преобразуются хэш-функцией в одно и тоже число.
   В этом случае хэш-таблица всё равно будет работать
   правильно, но с несколько сниженной производительностью.
   В редких случаях определенные типы ключей могут
   взаимодействовать с хэш-фукнцией, увеличивая кол-во
   коллизий и препятствуя способности приложения
   выполнять поиск, что ещё больше снижает производительность.
3. Неэффективность при использовании небольших таблиц:
   В очень маленьких таблицах время создания и поиска,
   требуемое хэш-таблицами, может сделать их менее
   неэффективными, чем более простые структуры, такие как
   списки. Преимущества хэш-таблци в производительности
   становятся заметными только при хранении в них
   больших объемов данных.
4. Изменяющаяся скорость выполнения операций:
   В common lisp при создании небольшой таблицы,
   а затем добавление в неё новых значений, может
   происходить очень медленно.
   Это происходит из за того что лиспу нужно время
   на выделение дополнительной памяти, чтобы таблица
   могла содержать больше элементов.

   Ещё одной причиной может стать что они не так удобны как списки.
   Сложнее отлаживать.
   Есть правило - держаться подальше от массивов и хэш-таблиц,
   когда создаётся новый кусок кода. После того как производительность
   стала проблемой, разумно изменить критические участки кода.

** Common lisp структуры
Структура - это расширенный тип данных, доступный в Common lisp.
Структуры и их свойтсва могут быть полезным способом предствления
данных в коде

Структуры можно использовать для предствления объектов со
свойствами, как это можно делать в обычном OOP языке

#+BEGIN_SRC lisp
  (defstruct person
    name
    age
    waist-size
    favorite-color)
#+END_SRC

Согласно определению в этой структуре preson имеет 4 свойства
(также называемые slots лисперами):
name age waist-size favorite-color

После определения структуры мы можем создавать экземпляры
с помощью make-*** - спец функции, которую defstruct
автоматически создал для нас:

#+BEGIN_SRC lisp
  (defparameter *bob* (make-person :name "Bob"
                                   :age 35
                                   :waist-size 32
                                   :favorite-color "blue"))
#+END_SRC

Так же мы узнать о структуре через автоматически созданные
функции (person-***) где *** - это имя слота.

#+BEGIN_SRC lisp
  (person-age *bob*)
#+END_SRC

Читатель лиспа так же может создать person непосредственно из
его печатного изображения

#+BEGIN_SRC lisp
  (defparameter *that-guy* #S(person :name "Bob"
                                     :age 35
                                     :waist-size 32
                                     :favorite-color "blue"))

  (person-age *that-guy*) ; 35
#+END_SRC

** Работа с данными в общем виде
Работа с последовательностями, это самый частый способ
работы функции на различных данных.

Например функция length. (так же есть list-length что более
производительна, но предпочтение идёт обобщённой функции length)

Функции последовательности для поиска:
1. find-if - находит первое значение, удовлетворяющее предикату.
2. count - находит как часто определенный объект появляется в
   последовательности
3. position - находит позицию элемента.
4. some, every - говорят, подчиняется ли некоторое или
   каждое значение в последовательности определенному предикату.

Одной из самых полезных функций является reduce для сверстки.

Так же одной из полезных функций является map, но в отличии от
mapcar, функция map работает со всеми типами последовательностей.

Две самых важнейших функций над последовательностями:
1. Функция subseq позволяет вычленить подпоследовательность
   из большей последовательности, указав начало и конец.

   #+BEGIN_SRC lisp
     (subseq "america" 2 6) ; "eric"
   #+END_SRC

2. Функия sort позволяет передать произвольную функцию для сортировки.

   #+BEGIN_SRC lisp
     (sort '(5 8 2 4 9 3 6) #'<)
   #+END_SRC

** Создание своей обобщённой функции с типом предеката

Common lisp является динамически типизированным языком.
Имеет смысл иметь набор функций которые позволяют определить
есть ли в переменной данные определенного типа.

Мы можем попробовать написать функцию add от данных типа

#+BEGIN_SRC lisp
  (defun add (a b)
    (cond
      ((and (numberp a) (numberp b)) (+ a b))
      ((and (listp a) (listp b)) (append a b))))
#+END_SRC

Хотя это и возможно большинство лисперов не стали бы
писать функцию add таким образом по следующим причинам:

1. Единая, монолитная функция для всех типов:
   Это хорошо для двух типов, но если бы мы работали с
   десятками типов, функция быстро бы превратилась в чудовище.
2. Изменения, необходимые для учета новых случаев:
   Пришлось бы изменять add каждый раз, когда нужно будет
   поддержать новый тип, что увеличивает вероятность того,
   что мы сломаем существующий код.
3. Трудно понять:
   Трудно понять что именно делает главный оператор cond и
   все ли типы направляются в нужное место.
4. Производительность:
   Если бы интерпретатор/компилятор Lisp знал что
   функция точно принимает 2 списка, то он бы мог создать
   более быстрый код. Однако чтобы проверить типы,
   нужно тратить ресурсы.

Поскольку иметь обобщённые функции очень удобно,
функция demethod позволяет нам определить несколько
версий функции, каждая из которых поддерживает различные типы.
Когда Common lisp вызывает функцию, он проверяет типы на
момент вызова, и автоматически выбирает правильную версию.
Этот термин называется - диспетчеризация типов.

#+BEGIN_SRC lisp
  (defmethod add ((a number) (b number))
    (+ a b))

  (defmethod add ((a list) (b list))
	   (append a b))
#+END_SRC

В таком варианте код лучше для понимания и транслятора.
Комбинация defstruct и defmethod по сути,
предствляет собой простую объектную систему.

** Итогы
1. Массивы похожи на списки, но позволяют более эффективно
   обращаться к элементам с определенным смещением.
2. Хеш-таблицы похожи на списки, но позволяют более эффективно
   искать значение, связанное с ключом.
3. Использование массивов и хэш-таблиц в нужных местах обычно
   делает программу намного быстрее.
4. Единственный способ узнать, ускорит ли изменение структуры
   данных или алгоритма работу программы, - это засечь время
   выполнения кода с помощью команды time.
5. В Common Lisp есть общие функции, которые можно использовать для
   работы с различными типами данных. Наиболее полезные из них
   являются функции последовательности, которые работают
   прозрачно работать с разными типами.
6. Можно создавать объекты со свойствами в списке с помощью
   команды defstruct.

* 10 Циклы с loop командой
** loop макрос
С помощью loop можно выполнить любой тип цикла, который когда-либо захочешь сделать.

#+BEGIN_SRC lisp
  (loop :for i
        :below 5
        :sum i)
#+END_SRC

Этот код складывает числа ниже пяти
0 + 1 + 2 + 3 + 4 = 10

Эта команда цикла не работает так, как должна работать правильная команда Lisp.
Во-первых, в ней нет скобок. 7 лексем без круглых скобок.

1. for - определяет переменную для итерирования. По умолчанию с нуля.
2. below - указывает остановиться когда достигнет числа
3. sum - складывает все значения

Используя for и to, можно посчитать любой определенный диапазон чисел

#+BEGIN_SRC lisp
  (loop :for i
        :from 5
        :to 10
        :sum i)
#+END_SRC

Итерирование в списке

#+BEGIN_SRC lisp
  (loop :for i
        :in '(100 20 3)
        :sum i)
#+END_SRC

:do - токен принимает произвольное выражение и выполняет его внутри цикла

#+BEGIN_SRC lisp
  (loop :for i
        :below 5
        :do (print i))
#+END_SRC

:when - токен позволяет запускать часть цикла только по необходимости

#+BEGIN_SRC lisp
  (loop :for i
        :below 10
        :when (oddp i)
        :sum i)
#+END_SRC

Этот цикл содержит новые трюки

#+BEGIN_SRC lisp
  (loop :for i
        :from 0
        :do (print i)
        :when (= i 5)
        :return 'falafel)
#+END_SRC

Этот цикл идёт от нуля до бесконечности. Однако, как только мы достигаем 5,
условие when заставляет вернуть falafel

:collect - позволяет вернуть элементы в виде списка

#+BEGIN_SRC lisp
  (loop :for i
        :in '(2 3 4 5 6)
        :collect (* i i))
#+END_SRC

Так же loop макрос позволяет делать более одного for варианта.

#+BEGIN_SRC lisp
  (loop :for x :below 10
        :for y :below 10
        :collect (+ x y))
#+END_SRC

Чтобы получить вложенный вариант цикла можно написать так

#+BEGIN_SRC lisp
  (loop :for x :below 10
        :collect (loop :for y :below 10
                       :collect (+ x y)))
#+END_SRC

Цикл для отслеживания индекса

#+BEGIN_SRC lisp
  (loop :for i
        :from 0
        :for day
        :in '(monday tuesday wednesday thursday friday saturday sunday)
        :collect (cons i day))
#+END_SRC

Это ещё не всё!

Детальная работа макроса loop:

Простой loop:

#+BEGIN_SRC lisp
  (loop
    (princ "type something")
    (force-output)
    (read))
#+END_SRC

do* - итерирование

#+BEGIN_SRC lisp
  (loop :for i :below 5
        :do (print i))
#+END_SRC

with - позволяет создать локальную переменную

#+BEGIN_SRC lisp
  (loop :with x = (+ 1 2)
        :repeat 5
        :do (print x))
#+END_SRC

repeat - повторение n раз

#+BEGIN_SRC lisp
  (loop :repeat 5
        :do (print "Prints five times"))
#+END_SRC

return - делает возврат из цикла

#+BEGIN_SRC lisp
  (loop :for i :below 10
        :when (= i 5)
        :return
        'leaving-early
        :do (print i))
#+END_SRC

initially - делает действие один раз в начале цикла

#+BEGIN_SRC lisp
  (loop :for i :below 10
        :when (= i 5)
          :return
        'leaving-early
        :do (print i))
#+END_SRC

finally - делает действие в конце цикла

#+BEGIN_SRC lisp
  (loop :for x :below 3
        :do (print x)
        :finally
        (print 'loop-end))
#+END_SRC

named - даёт метку для внешнего цикла, а return-from позволяет прыгнуть на метку

#+BEGIN_SRC lisp
  (loop :named outer
        :for i :below 10
        :do (progn
              (print "outer")
              (loop :named inner
                    :for x :below i
                    :do (print "**inner")
                    :when (= x 2)
                      :do (return-from outer 'kicked-out-all-the-way))))
#+END_SRC

while - позволяет итерироваться пока истинно условие
until - позволяет итерироваться пока ложно условие

#+BEGIN_SRC lisp
  (loop :for i :in '(0 2 4 555 6)
        :while (evenp i)
        :do (print i))

  (loop :for i :from 0
        :do (print i)
        :until (> i 3))
#+END_SRC

Итерирование по hash-tables

Такие команды как
using - использовать ключ или значение
например :using (hash-value x) или :using (hash-key x)

being - начало команды итерирования по hash-table
the(each) - следующая фраза

далее выбор итерация по ключу или значению 
hash-key(hash-keys) 
hash-value(hash-values)

и в конце :of и имя таблицы

#+BEGIN_SRC lisp
  (defparameter salary (make-hash-table))

  (setf (gethash 'bob salary) 80)
  (setf (gethash 'john salary) 90)

  (loop :for person :being :each :hash-key :of salary
        :using (hash-value amt)
        :do (print (cons person amt)))

#+END_SRC

:for или :as - для итерации с переменной

#+BEGIN_SRC lisp
  (loop :as x ; same :for
        :from 5
        :to 10
        :collect x)
#+END_SRC

:in или :on - для итерации в списке

#+BEGIN_SRC lisp
  (loop :for x
        :on '(1 3 5) ; same :in
        :do (print x))
#+END_SRC

:across - для итерации по массиву

#+BEGIN_SRC lisp
  (loop :for i
        :across #(100 20 3)
        :sum i)
#+END_SRC

Набор комманд для контроля инкрементации
:by - для контроля шага
:from - для контроля старта
:to - для контроля конца
:upfrom - начать с 6 в вверх
:upto - до какого-то числа вверх
:downfrom - начать с 6 и вниз
:downto - до какого-то числа вниз
:then - для итерации по двум значения в сумме с for =

#+BEGIN_SRC lisp
  (loop :for i
        :from 0
        :to 8
        :by 2
        :sum i)
#+END_SRC

:into создать локальную переменную для возврата в которую будет идти результат
одного из слов (:sum :minimize ...)

#+BEGIN_SRC lisp
  (loop :for x :from 1 :to 3
        :sum x :into res
        :do (print x)
        :finally (print res))
#+END_SRC

Проверки коллекций на условия (комбинация when/return)
:always - если значение правда то return
:never - если значение не правда то return
:thereis - если значение один раз совпало то return

#+BEGIN_SRC lisp
  (loop :for x :in '(1 x 3)
        :thereis (numberp x)
        :do (print x))
#+END_SRC

Создание условий

:if - если условия истина тогда делать то
:when - тоже самое что if но нельзя дописать :else
:unless - если условия лож тогда делать то
:and - расширить форму и добавить ей ещё одно тело
:end - закрыть тело

#+BEGIN_SRC lisp
  (loop :for i :below 4
        :when (oddp i)
        :do (print i)
        :and
        :do (print (* i i))
        :end
        :do (print "yup!"))
#+END_SRC

Экстрагирующие результат токены
:count* - вернуть количество раз
:sum* - вернуть сумму
:minimize* - вернуть минимум
:maximize* - вернуть максимум
:append* - собрать коллекцию списков в 1
:nconc* - собрать новые пары в 1

#+BEGIN_SRC lisp
  (loop :for x :in '(abc a b c)
        :count x)
#+END_SRC

** Итогы
1. Команда loop - это универсальный магазин циклов.
2. Чтобы посчитать числа в цикле, используется фраза :for
3. Чтобы перебрать коллекцию, используется фраза :for :in
4. Можно собрать элементы и вернуть в виде списка :collect
5. Обращатся к документации по циклу чтобы стать мастером.

* 11 Печать текста с функцией формата
** Анатомия format функции
Пример format использования

#+BEGIN_SRC lisp
  (format t "Add onion rings for only ~$ dollars more!" 1.5)
#+END_SRC
  
| (format       | t                                  | "Add onion rings for only | ~$                 | dollars more!" |      1.5) |
| вызов функции | параметер направления              | текст                     | управляющий символ | текст          | параметер |
|               | nil = создать строку;              |                           |                    |                |           |
|               | t = напечатать в *standard-output* |                           |                    |                |           |
|               | stream = указать поток для вывода  |                           |                    |                |           |

Например мы просто отформатируем строку

#+BEGIN_SRC lisp
  (princ
   (format nil "Add onion rings for only ~$ dollars more!" 1.5))
#+END_SRC

~$ - говорит о денежном форматировании с плавающей запятой.

для печати объектов использовались функции prin1 и princ

Того же поведения можно добиться использовав ключи:
~s - копирующий поведение prin1
~a - копирующий поведение princ

Так же можно отредактировать выравнивание по пробелам написав ~10a, добавит 10 пробелов
справа от текста вычитая длину. А также ~10@a слева.

В управляющие символы можно передавать аргументы через запятую, например ~10,3a
что говорит добавлять пробелы по 3 штуки за раз, таким образом общая ширина стала 12.

~x - печать в 16-ричной системе
~b - печать в 8-ричной системе
~d - печать в 10-тичной системе

в ключе ~d можно поставить аргументы для разделения числа при печати ~:d

~f - печать плавающих чисел

~% - печать с новой строки (terpri)
~& - печать с новой если нужна (fresh-line)

С помощью format возможно распечатать таблицу

#+BEGIN_SRC lisp
  (defun random-animal ()
    (nth (random 5) '(dog tick tiger walrus kangaroo)))

  (loop :repeat 10
        :do (format t "~5t~a ~15t~a ~25t~a~%"
                    (random-animal)
                    (random-animal)
                    (random-animal)))
#+END_SRC

Предположим что мы хотим чтобы вывод был на расстоянии друг от друга на одной строке.

#+BEGIN_SRC lisp
  (defun random-animal ()
    (nth (random 5) '(dog tick tiger walrus kangaroo)))

  (loop :repeat 10
        :do (format t "~30<~a~;~a~;~a~>~%"
                    (random-animal)
                    (random-animal)
                    (random-animal)))
#+END_SRC

~30< - всё должно иметь ширину 30 символов
~a - значение
~; - разделить нового значения
~> - закрытие разделения


:@ - позволит создать выровненую последовательность

#+BEGIN_SRC lisp
  (loop :repeat 10
        :do (format t "~30:@<~a~>~%" (random-animal)))
#+END_SRC

для печати всех значний ровно по центру

Чтобы в итерироваться по списку используются пары ~{ и ~}

#+BEGIN_SRC lisp
  (format t "~{I see you ~a~%~}~%" '(frodo golum sam))
#+END_SRC

** Безумные трюки с форматом для создания красивых таблиц данных
Приведём пример компибинирования УП для получения сложного поведения

#+BEGIN_SRC lisp
  (format t "|~{~<|~%|~,33:;~2d ~>~}|" (loop :for x :below 100 :collect x))
#+END_SRC

** Итогы
1. Первый параметр команды format определит направление результата
2. Второй параметр команды format определит способ печати данных.
   Управляющая строка имеет сложный синтаксис, действуя почти как
   самостоятельный язык.
3. Остальный параметры команды format это значения на которые можно ссылаться
   из управляющей строки.
4. Чтобы вставить значение в строку, используются символы ~s или ~a
5. Множество управляющих символов доступны для печати и настройки внешнего вида
6. format - обладает возможностями зацикливания, которые можно использовать,
   например, для форматирования таблиц, оформленных в различных стилях.

* 12 Работа с потоками
Потоки - это тип данных в common lisp, которые позволяют взять какой-либо внешний ресурс
и сделать его похожим на ещё один простой фрагмент данных, которым вы можете манипулировать
в своем коде. Внешний ресурс может быть самым разным: файл на диске, другой компьютер
в сети или текст в консоли.

** Типы потоков
Когда мы общаемся с внешним ресурсом из программы, мы делаем это с помощью потока.
Различные типы для различных потоков. Другим фактором является направление потока -
иногда нужно записать данные в ресурс, а иногда - прочитать данные из ресурса.

Наиболее часто используемые типы потоков:
1. Консольные потоки - то что используется при общении с REPL.
2. Файловые потоки - позволяют нам читать и записывать файлы на диск.
3. Потоки сокетов - позволяют общаться с другими компьютерами по сети.
4. Строковые потоки - позволяют отправлять и получать текст из строк Lisp.

Из всех этих типов потоков, строковые потоки являются "чёрной овцой" в семье.
Строковые потоки не столько позволяют общаться с внешним миром, сколько
позволяют манипулировать строками новыми и интересными способами.

** Направления потоков
Когда мы пишем данные в ресурс, используются выходные(output) потоки.
Когда мы читаем данные из ресурса, используются входные(input) потоки.

input -> программа -> output

** Output-потоки
Output-потоки используются для таких задач как запись в repl, запись
в файл или отправка информации через soket.

На самом примитивном уровне с output-потоком можно сделать две вещи:
1. Проверить, действителен ли поток.
2. Вставить новый элемент в поток.

Поток является очень ограничем, чем настоящая структура данных в Lisp.
Например список поддерживает все теже функции что и поток, а также
можно выполнять определенные задачи со списком,
но не можем выполнить с потоком. (изменить элемент с помощью setf)

Но эта ограниченость является на полезной.
Чтобы проверить есть ли у нас рабочий поток вывода, можно использовать функцию

#+BEGIN_SRC lisp
  (output-stream-p *standard-output*)
#+END_SRC

Символ Lisp - это такой элемент который может быть записан в поток с помощью
команды write-char.

#+BEGIN_SRC lisp
  (write-char #\x *standard-output*)
#+END_SRC

В common lisp также возможно создать потоки на основе других типов данных.

** Input-потоки
Input-потоки используются для чтения данных.

На самом примитивном уровне с input-потоком можно сделать две вещи:
1. Проверить, действителен ли поток.
2. Вытащить элемент из потока.

Чтобы проверить есть ли у нас рабочий поток ввода, можно использовать функцию

#+BEGIN_SRC lisp
  (input-stream-p *standard-input*)
#+END_SRC

Мы можем прочитать элемент из потока с помощью команды read-char.
Поскольку мы читаем из REPL, нужно набрать несколько символов и нажать ENTER
для отправки данных в стандартный поток ввода.

#+BEGIN_SRC lisp
  (read-char *standard-input*)
#+END_SRC

** Другие команды взаимодействия с потоками
Момимо write-char и read-char, в Common lisp есть много других команд
для работы с потоками.

Фактически все команды печати и чтения, могут принимать поток в
качестве доп. параметра.

#+BEGIN_SRC lisp
  (print 'foo *standard-output*)
#+END_SRC

** Работа с файлами
Лучший способ создать файловый поток в Common Lisp - это использовать
команду with-open-file.

#+BEGIN_SRC lisp
  (with-open-file (my-stream "data.txt"
                             :direction :output)
    (print "My data" my-stream))
#+END_SRC

Команда связывает поток вывода с my-stream.
В результате будет создан поток вывода файла с именем my-stream.
Этот поток будет доступен в теле команды и все данные что мы
отправим в этот поток окажутся в файле "data.txt" на диске.

Указание ключа :direction :output - создаёт выходной поток,
но можно указать так же ключ :input

#+BEGIN_SRC lisp
  (with-open-file (my-stream "data.txt"
                             :direction :input)
    (read my-stream))
#+END_SRC

Более сложный пример записи alist в файл

#+BEGIN_SRC lisp
  (let ((animal-noises '((dog .woof) (cat . meow))))
    (with-open-file (my-stream "animal-noises.txt"
                               :direction :output)
      (print animal-noises my-stream)))
#+END_SRC

Команда with-open-file принимает ключивые параметры, например
:if-exists чтобы указать что делать если файл существует
можно указать :error или :supersede. :error - выкинет ошибку, а
:supersede - перезапишет файл.

Команда with-open-file предоставляет очень лаконичный способ
работы с файлами. В отличие от большинства языков программирования,
при использовании команды не нужно переживать о закрытии файла вручную,
или беспокоиться о том что они были не закрыты должным образом.

В common lisp есть множество команд, начинающихся с with-, которые
безопасно распределяют ресурсы.

** Работа с сокетами
Сокет - это механизм для маршрутизации данных по компьютерной сети
между программами, работающими в одной сети.
В стандарте common lisp нет сокетов, но каждая реализация поддерживает свои.

cl-sockets или usocket - две стандартные библиотеки работы с сокетами.

** Адреса сокетов
Каждый сокет имеет адрес сокета. Этот адрес состоит из двух компонентов

1. Ip address - число, которое однозначно идентифицирует компьютер в сети
   (отображается в виде 4 байт, разделенных точками, например: 192.168.33.22)
2. Port number - число которое однозначно идентифицирует программу в сети

Ip-адрес и номер порта вместе составляют адрес сокета.
Любые сообщения, передаваемые по сети (пакеты TCP), помечаются адресом сокета
для указания их назначения.

Когда компьютер получает пакет, помеченный его Ip-адрессом, ОС смотрит
на номер порта в адресе сокета, чтобы определить какая программа должна
получить сообщение.

** Соединение сокетов
Для того чтобы отправить сообщение через сокет между программами,
нужно выполнить несколько шагов для инициализации.
Первым шагом является создание одной из программ сокета,
который запускается в состоянии прослушивания и ждёт, не
захотят ли другие программы в сети начать обмен данными.

Компьютер с сокетом в состоянии прослушивания называется сервером.

Затем другая программа, называемая клиентом, создаёт сокет
на своей стороне и использует его для установления соединения с сервером.


*дальше я использовал библиотеку usocket и netcat*

** Строковые потоки: странный тип
Потоки обычно используются для связи с внешним миром изнутри программы.
Исключением является строковый поток, который просто делает строку
похожей на поток.

Строковые потоки можно создать с помощью make-string-output-stream и
make-string-input-stream

#+BEGIN_SRC lisp
  (defparameter foo (make-string-output-stream))
  (princ "This will go into foo. " foo)
  (princ "This will also go into foo. " foo)
  (get-output-stream-string foo)
#+END_SRC

Такие строки полезны для отладки, а также для эффективного создания
сложных строк.

Использование потоков строк позволяет использовать функции, требующие
потоков в качестве параметров.
Например, предположим, что у нас есть функция write-to-log,
которая записывает информацию журнала в поток. Обычно мы хотим
отправить информацию журнала в файловый поток, чтобы сохранить
её на диске. Однако, если мы хотим отладить функцию, мы можем отправить ей
строковый поток, чтобы посмотреть на данные, которые она записывает, и
убедиться в их правильности.
Если бы мы закодировали функцию write-to-log только для записи в файл,
не было бы такой гибкости.

Потоки строк могут привести к улучшению производительности кода
при работе с очень длинными строками.
Например конкатенация двух строк может быть очень дорогой,
из-за этого узкого места, многие языки используют string builders
чтобы избежать накладных расходов. В Lisp можно получить
аналогичный выигрыш в производительности, используя потоки строк.

Пример облегчающий чтение и отладку кода

#+BEGIN_SRC lisp
  (with-output-to-string (*standard-output*)
    (princ "the sum of ")
    (princ 5)
    (princ " and ")
    (princ 2)
    (princ " is ")
    (princ (+ 2 5)))
#+END_SRC

Макрос with-output-to-string перехватывает любой текст, который
иначе был бы выведен в консоль, REPL или другой поток вывода,
и преобразовывает его в строку.

Когда макрос выходит из тела, результат возвращается ввиде строки.
Легко создавать сложные строки печатая каждую часть, а затем захватывая
результат в виде строки. Это гораздо более красиво и эффективно, чем
использование concatenate.

*ПРИМЕЧАНИЕ* использование with-output-to-string противоречит принципам
функционального программирования. В сообществе Lisp можно встретить
разногласия по поводу того, является ли использование with-output-to-string
элегантным или уродливым.

** Итогы
1. Различные типы потоков взаимодействуют с различными типами ресурсов.
   Такие как консольные потоки, файловые потоки, потоки сокетов и потоки строк.
2. Потоки можно разделить на выходные и входные.
3. Потоки сокетов позволяют компьютерам обмениваться данными по сети.
   Чтобы создать поток сокетов, мы должны открыть сокеты на обоих концах
   и открыть сокетное соединение между программами.
4. Потоки строк позволяют использовать функции, требующие потоков, без
   связи с внешним ресурсом, в целях отладки. Они также полезны для
   эффективного построения сложных строк.

* 13 Давайте создадим web-server!
** Обработка ошибок в common lisp
Если при написании функции что-то идёт не так, функция Lisp может
сообщить окружению lisp о возникновении проблемы. Это делается путём
signaling a condition(сигнализации условия).

Какие вещи могут пойти не так? Деление на 0, неправильный параметр и тд...
Если нужно сигнализировать напрямую о ошибке, это делается через команду error.
Использование error прервет выполнение Lisp-программмы, если только ошибка не
будет перехвачена в другом месте, чтобы предотвратить прерывание.

#+BEGIN_SRC lisp
  (error "foo")
#+END_SRC

Сигнал заставил Lisp прервать программу, вывести сообщение "foo"
и показать подсказку об ошибке в REPL.

** Создание своих условий

#+BEGIN_SRC lisp
  (define-condition foo () ()
    (:report (lambda (condition stream)
               (princ "Stop FOOing around, numbskull!" stream))))
#+END_SRC

Создание условие с именем foo. когда будет кинуто исключение, пользователю
предоставится функция где будет текст ошибки.

#+BEGIN_SRC lisp
  (error 'foo)
#+END_SRC

** Условия перехвата

Когда создано условие через define-condition, ему присваивается имя. Это
имя может быть использовано более высокоуровневыми частями программы для
взаимодействия и обработки этого условия, чтобы оно не останавливало
выполнение программы. Это можно сделать через handler-case

#+BEGIN_SRC lisp
  (defun bad-fun ()
    (error 'foo))

  (handler-case (bad-fun)
    (foo () "somebody signaled foo!")
    (bar () "somebody signaled bar!"))
#+END_SRC

Первый аргумент это фрагмент кода, который может сигнализировать об условиях,
которые нужно обработать.
Остальная часть команды позволяет указать действия, которые нужно выполнить
при возникновении определенного условия.

Когда выполняется этот код, bad-fun сигнализирует об ошибке, тогда обработчик
перехватывает условие foo и программа продолжит выполнятся без прерывания.

** Защита ресурсов от непредвиденных условий
Когда в программе происходит исключение, есть риск, что это может нанести
вред за пределами программы. Исключения прерывают поток кода, и могут остановить
его в любой момент.

Например при записи в файл или поток сокета, в этом случае важно закрыть
файл/поток, в противном случае ресурс может оказаться заблокированным.

Команда unwind-protect может помочь избежать таких ситуаций.

#+BEGIN_SRC lisp
    (unwind-protect (/ 1 0)
      (princ "I need to say 'dofjoirg' matter what"))
#+END_SRC

Обычно можно избежать прямого вызова unwind-protect
полагаясь на макросы with-* которые сами вызывают функцию.


** Итогы
1. В common lisp можно сигнализировать об ошибках
   с помощью функции error. Перехватить ошибки с
   помощью функции handle-case. Если есть код
   который должне быть выполнен вне зависимости от ошибки,
   тогда его нужно поместить в функцию unwind-protect.
2. Веб-сервер обрабатывает HTTP-запросы. Самый
   распространенный тип запроса - GET, используется
   для просмотра информации. Другой тип - POST,
   используется при отправке веб-форм.
   Тип запроса, какая страница была запрошена, а
   также другую информацию можно определить
   посмотрев на заголовок запроса.
   GET - передаёт параметры в заголовке.
   POST - передаёт параметры в теле.

* 14 Повышение уровня lisp с помощью функционального программирования
** Что такое функциональное программирование?
ФП - это "стиль программировния, при котором весь
код написан с помощью функций". Однако мы имеем в виду
нечто очень специфическое, когда используем термин
функция в этом контексте - точно то же самое, что имеют
ввиду математики, когда используют слово функция.

| Domain | Range |
| ------ | -->   |
| ------ | -->   |
| ------ | -->   |
| ------ | -->   |

Показано, что функция имеет аргументы, которые
могут входить в неё, называемые domain(областью) функции.
Затем функция принимает эти аргументы и возвращает значение.
Считается, что это значение попадает в область range(действия) функции.

Вот важные свойства математических функций,
которым должны подчиняться функции Lisp:
1. Функции всегда возвращают один и тот же результат, если в неё
   передаются одни и те же аргументы. (Ссылочная прозрачность)
2. Функция никогда не ссылается на переменные, определенные вне
   функции, если только, эти переменные не будут константны.
3. Никакие переменные не изменяются(мутируют) функцией.
4. Цель функции - ничего не делать, кроме как возвращать результат.
5. Функция не делает ничего видимого для внешнего мира, например,
   не выводит на экран диалоговое окно или не заставляет компьютер
   делать "Bing!".
6. Функция не получает информацию из внешнего источника, например,
   с клавиатуры или жёсткого диска.

   
Если соблюдаются правила всегда, когда это возможно, можно сказать
что код написан в функциональном стиле.

Отличным примером математической функции является функция синуса

#+BEGIN_SRC lisp
  (sin 0.5)
#+END_SRC

Центральная идея ФП гласит что вы должны разбить программу на 2 части:
1. Первая, самая большая часть, должна быть полностью функциональной
   и не иметь побочных эффектов. Это чистая часть программы.
2. Вторая, меньшая часть программы - это та часть, которая имеет все
   побочные эффекты. взаимодействует с пользователем и остальным
   внешним миром. Этот код является грязным и должен быть как можно меньше.

** Анатомия программ, написаных в функциональном стиле
Напишим простую программу, которая следует фп стилю.
Поскольку мы хотим, чтобы эта программа была типичным примером
большинства программ, мы должны выяснить, что на самом деле
делает большинство программ в мире.
Что же они делают? Отслеживают виджеты!

#+BEGIN_SRC lisp
  ;; чистая, функциональная часть
  (defun add-widget (database widget)
    (cons widget database))

  ;; грязная, не функциональная часть
  (defparameter *database* nil)

  (defun main-loop ()
    (loop
     (princ "Please enter the name of a new widget:")
     (setf *database* (add-widget *database* (read)))
     (format t "The database contains the following: ~a~%" *database*)))
#+END_SRC

Поскольку пример маленький, грязная часть получилась немного больше.
Обычно можно ожидать, что чистая часть будет составлять около 80% от кода.

Что делает программа? Она делает то для чего создано большинство
компьютеров в мире: Работает с базой данных.
Поскольку функция add-widget чистая, она не может ничего изменять.
Это означает, что единственный способ "добавить" виджет в базу данных -
это вернуть новое значение. Для этого она берёт переданную базу данных,
а затем присоединяет виджет к базе данных, создавая новую базу данных.

Звучит безумно! Представте, что мы запускаем сервер базы данных Oracl,
содержащий миллионы виджетов, затем после добавления виджета, сервер
базы данных создаёт совершенно новую копию предыдущей базы данных,
которая отличается только тем, что был добавлен элемент!

Это было бы ужасно неэффективно. В нашем примере с виджетами все не так
плохо, как может показаться на первый взгляд. Действительно, функция
add-widget при каждом вызове создаёт новый списко виджетов, и
повторные вызовы делают его всё длинее и длинее. Однако, поскольку
каждый виджет добавляется в начало списка, получается, что хвоставая часть
идентична предыдущей версии списка.
Следовательно, функция add-widget может обманывать при создании списка
просто добавляя новый элемент в начало, а затем переиспользовать старый
список. Это позволяет создавать новый список очень быстро и требовать
мало памяти. Этот тип обмана является ключевым приемом, который
делает возможным эффективное фп. Более того, совместное использование
структур может быть безопасным, поскольку один из принципов фп -
не изменять старые части данных.

** Программирование высших порядков
Одним из распространенных камней преткновения для программистов,
которые учатся писать программы в функциональном стиле, является то,
что им трудно объединить различные фрагменты кода для выполнения
одного действия. Это называется композицией кода.

Допустим нам нужно прибавить 2 к каждому элементу списка:

#+BEGIN_SRC lisp
  (defparameter *my-list* '(4 7 2 3))
#+END_SRC

Одним из способ является использование цикла

#+BEGIN_SRC lisp
  (loop :for n :below (length *my-list*)
        :do (setf (nth n *my-list*) (+ (nth n *my-list*) 2)))
#+END_SRC

Это похоже на код, который мы бы могли написать на языке Си.
Хотя он довольно уродлив, есть и положительные моменты, которые можно сказать:

1. Код структурированный подобным образом, потанциально очень эффективен.
2. Код, написанный таким образом,
   явно объединяет задачу цикла и задачу прибавления двух к числу.

Но есть и отрицательные моменты:

1. Исходный список уничтожается. Это проблема если мы захотим использовать
   *my-list* позже.
2. Нам нужно создать переменную n, чтобы отслеживать позицию в списке.

Давайте перепишем этот код в функциональном стиле.
Для начала напишим его так, как мог бы написать начинающий
функциональный програмист, без использования программирования
высшего порядка:

#+BEGIN_SRC lisp
  (defun add-two (list)
    (when list
      (cons (+ 2 (first list)) (add-two (rest list)))))

  (add-two '(4 7 2 3))
#+END_SRC

Этот код позволяет избежать многих недостатков императвного решения.
Он не уничтожает исходный список и не требует использования индекса.
К сожалению, он также лишен одного из важнейших преимуществ
императивной версии: Больше нет четкого разграничения между кодом,
который добавляет двойки к элементам в списке, и кодом, который
обходит список.

Эти действия глубоко переплетены, пришлось создать спецальную функцию,
чтобы это решение работало.

Если мы хотим написать код для этой задачи в функциональном стиле, но
при этом сделать наш код композиционным, придётся использовать функции
высшего порядка. Вот так опытный лиспер добавит два к каждаму числу:

#+BEGIN_SRC lisp
  (mapcar (lambda (x)
            (+ x 2))
          '(4 7 2 3))
#+END_SRC

Эта версия, является функциональной и позволяет комбинировать код
обхода и код добавления. Это пример показывает что можно писать
чётко разграниченные куски кода и затем компоновать их, не отрываясь
от функционального стиля.

** Почему функциональное программирование это безумие
Мы уже знаем одну причину - функциональные программы на самом деле
ничего не могут сделать, поскольку у них не может быть побочных эффектов.
Как любит говорить Саймон Пейтон Джонс, известный функциональный програмист:
"Всё, что вы можете сделать без побочных эффектов, это нажать на кнопку
и посмотреть, как коробка нагревается в течение некоторого времени".
(Что технически не верно, поскольку нагревание коробки - это побочный эффект)

Можно обойти это разделив программу на две части. Но фп код может сделать
программу крайне неэффективной. Один из способов копирования - использование
общих структур между различными частями данных в программе.

К счастью, фп программисты разработали методы оптимизации,
которые могут решить подавляющее большинство проблем с производительностью.
Такие как мемоизация, оптимизации хвостовых вызовов, ленивая оценка
и программирование высшего порядка.

** Почему функциональное программирование это фантастика
Теперь после рассказа о головных болях, можно задасться вопросом
"Зачем кому-то нужно программировать таким образом?".
Ответ заключается в том, что фп имеет много заманчивых преимуществ,
которые компенсируют эти головные боли.

В ФП поведение зависит только от аргументов что облегчает оценку всех
обстоятельств.

ФП делает код более компактным

ФП - элегантно тк ближе к математике.

** Итогы
1. Программы написаные в функциональном стиле, всегда дают один и тот же
   реультат, если значения аргументов одни и те же.
2. Функциональные программы не содержат побочных эффектов.
3. Программы которые не ФП, читаются как повареная книга, такой
   стиль называется императивным
4. Хорошая стратегия написания программ на Lisp является разбиение
   их на чистую и грязную часть
5. Функциональные программы могут быть написаны быстро, они более
   компактны и имеют меньше ошибок.

* 15 Кости судьбы, игра, написанная в функциональном стиле
   Правила просты:
   1. Два игрока занимают места на шестиугольной сетке. На каждом шестиугольнике
      сетки лежит несколько шетсигранных игральных костей, принадлежащих игроку
   2. Во время хода игрок может сделать хотя бы один ход. Если игрок не может
      сделать ход, игра заканчивается. Ход заключается в атаке на соседний
      шестиугольник принадлежащий противнику. Для атаки игрок должен иметь больше
      костей в своем гексагоне, чем в соседнем гексагоне. На данный момент
      все атаки автоматически приводят к победе. В будущих вариантах
      мы действительно будет бросать кости для сражения. Но пока игрок
      с большим количеством костей просто автоматически побеждает.
   3. После победы в битве кости проигравшего игрока убирают с доски,
      а все кости победившего игрока, кроме одной, перемещаются на новый
      выигранный гексагон
   4. После того, как игрок закончил делать свои ходы, к армии этого игрока
      добавляются подкрепления. Подкрепления на занятые игроком гексагоны
      добавляются по одному кубику за раз, начиная с левого верхнего угла,
      двигаясь поперек и вниз. Максимальное количество кубиков. добавленных
      в качестве подкрепления, на один меньше, чем игрок забрал у противника в свой
      завершенный ход.
   5. Когда игрок больше не может делать свой ход, игра заканчивается.
      Игрок, занявший на этот момент наибольшее количество шестиугольников,
      становится победителем. (Ничья также возможна)
** Замыкания
Замыкания - это дополнительные кусочки данных из внешнего мира, которые
захватываются всякий раз, когда создается лямбда-функция.

#+BEGIN_SRC lisp
  (defparameter *foo* (let ((x 5))
                        (lambda () 5)))

  (funcall *foo*) ; 5
#+END_SRC

Переменные созданые таким путём, не обязательно локальные, если будут
захвачены в замыкание, поэтому переменные называют лексические.

Это возможно благодаря тому что лямбда ссылается на переменную,
поэтому сборщик мусора оставит её в покое, пока не пропадут все ссылки.

** Мемоизация
Эта техника использует замыкания.
Мемоизация работает только для функций, написанных в функциональном стиле.
Если мы будем запоминать аргументы и результат каждого вызова функции,
тогда не нужно будет пересчитывать результат.

** Оптимизация хвостового вызова
Для понимания концепции используем простую функцию длины списка

#+BEGIN_SRC lisp
  (defun my-length (list)
    (if list
        (1+ (my-length (rest list)))
        0))

  (my-length '(fie foh fum)) ; 3
#+END_SRC

Каждый раз при вызове лисп должен помнить что нужно добавить единицу
к результату позже, когда будет определена длина хвоста списка.
Если длина состовляет 100 000 элементов, он должен вспомнить об этом 99 999 раз,
предле чем выполнить одно сложение. Все эти напоминания хранятся в стеке программы,
который в конечном итоге может переполнится.

Чтобы избежать этой проблемы, нужно переписать функцию так

#+BEGIN_SRC lisp
  (defun my-length (list)
    (labels ((f (list acc)
               (if list
                   (f (cdr list) (1+ acc))
                   acc)))
      (f list 0)))
#+END_SRC

Когда функция в лиспе вызываем саму себя в качестве последнего действия,
это можно назвать хвостовым вызовом. Компилятор может увидеть это и
перейти к повторному вызову функции, без необходимости помещать контекст в стек.
Это похоже на GOTO или longjump.

В этой функции так же есть повторное определение list 2 раза, это называется
затенение переменной(variable shadowing).

В Common lisp нельзя быть на 100% уверенным что транслятор выполнит оптимизацию.
(В отличии от scheme где это строгое требование)

** Итогы
1. Методы фп позволяют написать игровую программу с "движком правил",
   который отделен от остального кода. Это достигается за счёт использования
   конвейеризации функций и построения дерева игры, которые независимо обходится
   другими частями игрового кода по ходу игры
2. Можно создать ИИ-игрока для игры двух игроков, используя алгоритм minimax.
   Этот алгоритм основан на трюизме "Что хорошо для моего врага, то плохо для меня"
   Он позволяет эффективно оценивать позиции в настольной игре для двух игроков.
3. Лексические переменные могут жить дальше той формы, в которой они были созданы,
   если на низ ссылается лямбда. Захват переменных таким образом называется замыкание.
4. Функциональные программы можно оптимизировать с помощью мемоизации, которая
   требует кэширования прошлых результатов, вычисленных функцией.
5. Так же можно улучшить функциональные программы, используя TCO, позволяя
   убедиться что стек вызовов не используется.
   

* 16 Магия лисп макросов
Иногда при написании програм можно почувствовать dejavu. Вам знакомо такое чувство
"Эй я уже 3 недели пишу один и тот же фрагмент кода!"

Давайте рассмотрим пример

#+BEGIN_SRC lisp
  (defun add (a b)
    (let ((x (+ a b)))
      (format t "The sum is ~a" x)
      x))
#+END_SRC

Функция add кажется простой, но код вызывает раздражение:
Зачем нужно так много скобок чтобы объявить одну переменную x?

Мы не можем написать функцию, чтобы скрыть лишнее,
потому что let - это особая форма.
Но макрос может. Создадим новый макрос let1

#+BEGIN_SRC lisp
  (defmacro let1 (var val &body body)
    `(let ((,var ,val))
       ,@body))
#+END_SRC

Определение макроса похоже на функцию, но он не вычисляет аргументы.
Прежде чем ядро лиспа увидит код, просходит расширение макросов (macro expansion)

** Как макросы преобразуются
Определяя макрос через defmacro мы добавляем в макро систему новое преобразование,
которое происходит перед запуском программы.
В качестве аргуметов макрос получает код в виде выражений лиспа.

&body - означает дай оставшуюся часть в виде списка.
,@ - в квазицитировании означает раскрыть список ,@(1 2 3) -> 1 2 3

Давайте посмотрим как теперь выглядит функция add

#+BEGIN_SRC lisp
  (defun add (a b)
    (let1 x (+ a b)
          (format t "The sum is ~a" x)
          x))
#+END_SRC

Мы так же можем просмотреть во что раскроется макрос с помощью macroexpand

#+BEGIN_SRC lisp
  (macroexpand '(let1 foo (+ 2 3)
                 (* foo foo)))
#+END_SRC

** Более сложные макросы
Создадим макрос split. Он позволит писать более чистые пожиратели списков.

#+BEGIN_SRC lisp
  (defmacro split (val yes no)
    `(if ,val
         (let ((head (car ,val))
               (tail (cdr ,val)))
           ,yes)
         ,no))
#+END_SRC

теперь мы можем переписать функцию my-length более чисто

#+BEGIN_SRC lisp
      (defun my-length (list)
        (labels ((f (list acc)
                   (split list
                          (f tail (1+ acc))
                          acc)))
          (f list 0)))
#+END_SRC

Мы используем переменную tail с помощью split, что упрощает код.
Макросы, автоматически генерирующие подобные переменные,
называются анафорическими макросами.

Хотя в принципе макрос работает, в нём есть ещё пару тонких ошибок.

Одна из распространенных ошибок, которая может возникнуть в макросе
это некорректное повторное выполнение кода.
Приведём пример

#+BEGIN_SRC lisp
  (split (progn (princ "Lisp rocks!")
                '(2 3))
         (format t "This can be split into ~a and ~a." head tail)
         (format t "This cannot be split."))
  ;; Lisp rocks!Lisp rocks!Lisp rocks!This can be split into 2 and (3).
#+END_SRC

При таком использовании "Lisp rocks!" было напечатано 3 раза, хотя в коде
встречается 1 раз.
Недолго думая можно решать проблему так

#+BEGIN_SRC lisp
  (defmacro split (val yes no)
    `(let1 x ,val
           (if x
               (let ((head (car x))
                     (tail (cdr x)))
                 ,yes)
               ,no)))
#+END_SRC

Но тут появляется новая ошибка при таком коде

#+BEGIN_SRC lisp
  (let1 x 100
        (split '(2 3)
               (+ x head)
               nil))
  ;; (2 3) это не число
#+END_SRC

Расширенная версия split содержит определение x. Это блокирует конкурирующее определение
в примере. В это случае макрос split захватил переменную x и переписал её.
Избежать этой проблемы можно создавая переменную с уникальным именем, в common lisp
этим занимается функция gensym.

#+BEGIN_SRC lisp
  (defmacro split (val yes no)
    (let1 g (gensym)
          `(let1 ,g ,val
                (if ,g
                    (let ((head (car ,g))
                          (tail (cdr ,g)))
                      ,yes)
                    ,no))))
#+END_SRC

Теперь функция split безопасная!
Если бы мы использовали эту функцию в другом коде, в котором head и tail имели бы
другое значние, то код был бы неудачным. Однако в случае с head и tail захват
переменных происходит намеренно. В этом случае захват является особенностью, а не ошибкой.

В коде my-length был повторяющийся паттерн: создание функции f.
Напишем макрос избавляющий от этого шума. Но для начала напишим функцию,
которая может группировать элементы в список пар

#+BEGIN_SRC lisp
  (defun pairs (list)
    (labels ((f (list acc)
               (split list
                      (if tail
                          (f (cdr tail) (cons (cons head (car tail)) acc))
                          (reverse acc))
                      (reverse acc))))
      (f list nil)))
#+END_SRC

#+BEGIN_SRC lisp
  (defmacro recurse (vars &body body)
    (let1 p (pairs vars)
          `(labels ((self ,(mapcar #'car p)
                      ,@body))
             (self ,@(mapcar #'cdr p)))))
#+END_SRC

Теперь перепишим my-length более чисто

#+BEGIN_SRC lisp
  (defun my-length (list)
    (recurse (list list
              acc  0)
             (split list
                    (f tail (1+ acc))
                    acc)))
#+END_SRC

** Макросы: Опасности и альтернативы
Макросы позволяют писать код, который создаёт другой код, что делает языки Lisp
прекрасным инструментом для метапрограммирования и создания прототипов новых
языковых идей. Но на каком-то уровне макросы - это просто ловкость рук.
Это мощный инструмент в арсенале, но он не так элегантен, как некоторые
другие средства, с которыми мы познакомились ранее. Основной недостаток,
что макросы могут затруднить понимание кода другими программистами. Ведь
если вы создаете свой собственный диалект языка, другие программисты не будут его знать.
Даже вы через год или два - можете с трудом разобраться в структуре вашего кода.
В связи с этим опытные лисперы стараются по возможности использовать альтернативные
макропрограммированию приёмы. Например добавив макросы split и recurse, мы могли
использовать приёмы из функционального программирования для решения этих задач и
использовать reduce.

#+BEGIN_SRC lisp
  (defun my-length (list)
    (reduce (lambda (x i)
              (1+ x))
            list
            :initial-value 0))
#+END_SRC

Очевидно что есть и другие сценарии, в которых макросы могут быть очень полезны, а
reduce не может быть использована так просто. Так что, в конечном счете,
есть ещё много ситуаций, когда создание собственного диалекта Lisp является
имеено тем решением проблемы, которые нужно.

** Итогы
1. Макросы позволяют писать код, который пишет код. С помощью макросов можно создать
   свой собственный язык программирования и преобразовать его в стандартный лисп.
2. Макросы позволяют избавиться от ощущения dejavu при написании кода в ситуациях,
   когда ничто другое этого сделать не может.
3. При написании макросов нужно быть осторожным, чтобы не приводить к повторяющимся
   вычислениям.
4. При написании макросов нужно быть осторожным, чтобы не приводить к непреднамеренному
   захвату переменных. Этого можно избежать благодаря gensym
5. Если переменные создаваемые макросом, раскрываются специально,
   как свойство макроса. то такой макрос называется анафорическим.
6. Макропрограммирование - очень мощный приём. Однако лучше использовать для решения
   задач функциональное программирование. Макросы всегда должны быть крайним средством.

* 17 Областно-специфические языки (DSL)

